/*
 * generated by Xtext 2.25.0
 */
package com.intuit.dsl.serializer;

import com.google.inject.Inject;
import com.intuit.dsl.expression.AddToDate;
import com.intuit.dsl.expression.ArithmeticSigned;
import com.intuit.dsl.expression.ArrayExpression;
import com.intuit.dsl.expression.BooleanExpression;
import com.intuit.dsl.expression.BooleanLiteral;
import com.intuit.dsl.expression.BooleanNegation;
import com.intuit.dsl.expression.CollectionFunction;
import com.intuit.dsl.expression.Comparison;
import com.intuit.dsl.expression.ConcatFunc;
import com.intuit.dsl.expression.Contains;
import com.intuit.dsl.expression.CurrentDate;
import com.intuit.dsl.expression.DateFormat;
import com.intuit.dsl.expression.DayDifference;
import com.intuit.dsl.expression.DedupFunc;
import com.intuit.dsl.expression.Delete;
import com.intuit.dsl.expression.Equals;
import com.intuit.dsl.expression.ExpressionPackage;
import com.intuit.dsl.expression.Extract;
import com.intuit.dsl.expression.FilterFunc;
import com.intuit.dsl.expression.FindFirstFunc;
import com.intuit.dsl.expression.FunctionReference;
import com.intuit.dsl.expression.Join;
import com.intuit.dsl.expression.Json;
import com.intuit.dsl.expression.Key;
import com.intuit.dsl.expression.LastFunc;
import com.intuit.dsl.expression.Length;
import com.intuit.dsl.expression.LowerFunc;
import com.intuit.dsl.expression.MapFunc;
import com.intuit.dsl.expression.MapStatement;
import com.intuit.dsl.expression.Membership;
import com.intuit.dsl.expression.Minus;
import com.intuit.dsl.expression.MultiOrDivOrMod;
import com.intuit.dsl.expression.NullLiteral;
import com.intuit.dsl.expression.NumberLiteral;
import com.intuit.dsl.expression.ParentFunc;
import com.intuit.dsl.expression.PickFirst;
import com.intuit.dsl.expression.Plus;
import com.intuit.dsl.expression.Property;
import com.intuit.dsl.expression.PropertyExpresssion;
import com.intuit.dsl.expression.Range;
import com.intuit.dsl.expression.RemoveFunc;
import com.intuit.dsl.expression.SchemaVariable;
import com.intuit.dsl.expression.SortFunc;
import com.intuit.dsl.expression.Split;
import com.intuit.dsl.expression.StringLiteral;
import com.intuit.dsl.expression.TernaryExpression;
import com.intuit.dsl.expression.TranslateUnicode;
import com.intuit.dsl.expression.UUIDFunc;
import com.intuit.dsl.expression.UpperFunc;
import com.intuit.dsl.expression.Variable;
import com.intuit.dsl.expression.VariableReference;
import com.intuit.dsl.services.ExpressionGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ExpressionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ExpressionGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionPackage.ADD_TO_DATE:
				sequence_AddToDate(context, (AddToDate) semanticObject); 
				return; 
			case ExpressionPackage.ARITHMETIC_SIGNED:
				sequence_Prefixed(context, (ArithmeticSigned) semanticObject); 
				return; 
			case ExpressionPackage.ARRAY_EXPRESSION:
				sequence_ArrayExpression(context, (ArrayExpression) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_LITERAL:
				sequence_LiteralExpression(context, (BooleanLiteral) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_NEGATION:
				sequence_Prefixed(context, (BooleanNegation) semanticObject); 
				return; 
			case ExpressionPackage.COLLECTION_FUNCTION:
				sequence_CollectionFunction(context, (CollectionFunction) semanticObject); 
				return; 
			case ExpressionPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case ExpressionPackage.CONCAT_FUNC:
				sequence_ConcatFunc(context, (ConcatFunc) semanticObject); 
				return; 
			case ExpressionPackage.CONTAINS:
				sequence_Contains(context, (Contains) semanticObject); 
				return; 
			case ExpressionPackage.CURRENT_DATE:
				sequence_CurrentDate(context, (CurrentDate) semanticObject); 
				return; 
			case ExpressionPackage.DATE_FORMAT:
				sequence_DateFormat(context, (DateFormat) semanticObject); 
				return; 
			case ExpressionPackage.DAY_DIFFERENCE:
				sequence_DayDifference(context, (DayDifference) semanticObject); 
				return; 
			case ExpressionPackage.DEDUP_FUNC:
				sequence_DedupFunc(context, (DedupFunc) semanticObject); 
				return; 
			case ExpressionPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case ExpressionPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case ExpressionPackage.EXTRACT:
				sequence_Extract(context, (Extract) semanticObject); 
				return; 
			case ExpressionPackage.FILTER_FUNC:
				sequence_FilterFunc(context, (FilterFunc) semanticObject); 
				return; 
			case ExpressionPackage.FIND_FIRST_FUNC:
				sequence_FindFirstFunc(context, (FindFirstFunc) semanticObject); 
				return; 
			case ExpressionPackage.FUNCTION_REFERENCE:
				sequence_Atomic(context, (FunctionReference) semanticObject); 
				return; 
			case ExpressionPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case ExpressionPackage.JSON:
				sequence_Json(context, (Json) semanticObject); 
				return; 
			case ExpressionPackage.KEY:
				sequence_Key(context, (Key) semanticObject); 
				return; 
			case ExpressionPackage.LAST_FUNC:
				sequence_LastFunc(context, (LastFunc) semanticObject); 
				return; 
			case ExpressionPackage.LENGTH:
				sequence_Length(context, (Length) semanticObject); 
				return; 
			case ExpressionPackage.LOWER_FUNC:
				sequence_LowerFunc(context, (LowerFunc) semanticObject); 
				return; 
			case ExpressionPackage.MAP_FUNC:
				sequence_MapFunc(context, (MapFunc) semanticObject); 
				return; 
			case ExpressionPackage.MAP_STATEMENT:
				sequence_MapStatement(context, (MapStatement) semanticObject); 
				return; 
			case ExpressionPackage.MEMBERSHIP:
				sequence_Membership(context, (Membership) semanticObject); 
				return; 
			case ExpressionPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case ExpressionPackage.MULTI_OR_DIV_OR_MOD:
				sequence_Multiplication(context, (MultiOrDivOrMod) semanticObject); 
				return; 
			case ExpressionPackage.NULL_LITERAL:
				sequence_LiteralExpression(context, (NullLiteral) semanticObject); 
				return; 
			case ExpressionPackage.NUMBER_LITERAL:
				sequence_LiteralExpression(context, (NumberLiteral) semanticObject); 
				return; 
			case ExpressionPackage.PARENT_FUNC:
				sequence_ParentFunc(context, (ParentFunc) semanticObject); 
				return; 
			case ExpressionPackage.PICK_FIRST:
				sequence_PickFirst(context, (PickFirst) semanticObject); 
				return; 
			case ExpressionPackage.PLUS:
				sequence_Addition(context, (Plus) semanticObject); 
				return; 
			case ExpressionPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case ExpressionPackage.PROPERTY_EXPRESSSION:
				sequence_Atomic(context, (PropertyExpresssion) semanticObject); 
				return; 
			case ExpressionPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case ExpressionPackage.REMOVE_FUNC:
				sequence_RemoveFunc(context, (RemoveFunc) semanticObject); 
				return; 
			case ExpressionPackage.SCHEMA_VARIABLE:
				sequence_SchemaVariable(context, (SchemaVariable) semanticObject); 
				return; 
			case ExpressionPackage.SORT_FUNC:
				sequence_SortFunc(context, (SortFunc) semanticObject); 
				return; 
			case ExpressionPackage.SPLIT:
				sequence_Split(context, (Split) semanticObject); 
				return; 
			case ExpressionPackage.STRING_LITERAL:
				sequence_LiteralExpression(context, (StringLiteral) semanticObject); 
				return; 
			case ExpressionPackage.TERNARY_EXPRESSION:
				sequence_TernaryExpression(context, (TernaryExpression) semanticObject); 
				return; 
			case ExpressionPackage.TRANSLATE_UNICODE:
				sequence_TranslateUnicode(context, (TranslateUnicode) semanticObject); 
				return; 
			case ExpressionPackage.UUID_FUNC:
				sequence_UUIDFunc(context, (UUIDFunc) semanticObject); 
				return; 
			case ExpressionPackage.UPPER_FUNC:
				sequence_UpperFunc(context, (UpperFunc) semanticObject); 
				return; 
			case ExpressionPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case ExpressionPackage.VARIABLE_REFERENCE:
				sequence_Atomic(context, (VariableReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Function returns AddToDate
	 *     AddToDate returns AddToDate
	 *
	 * Constraint:
	 *     (
	 *         dateExp=Expression 
	 *         (format='"MM/dd/yyyy"' | format='"yyyyMMdd"' | format='"yyyy-MM-dd"' | format='"ms"' | format=STRING) 
	 *         exp=Expression 
	 *         type='Days'
	 *     )
	 */
	protected void sequence_AddToDate(ISerializationContext context, AddToDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     BooleanExpression returns Minus
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0_0 returns Minus
	 *     Membership returns Minus
	 *     Membership.Membership_1_0_0 returns Minus
	 *     Equals returns Minus
	 *     Equals.Equals_1_0_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Plus_1_0_0_0_0 returns Minus
	 *     Addition.Minus_1_0_0_1_0 returns Minus
	 *     Multiplication returns Minus
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns Minus
	 *     Prefixed returns Minus
	 *     Atomic returns Minus
	 *     ParenthesizedExpression returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_0_1_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     BooleanExpression returns Plus
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0_0 returns Plus
	 *     Membership returns Plus
	 *     Membership.Membership_1_0_0 returns Plus
	 *     Equals returns Plus
	 *     Equals.Equals_1_0_0 returns Plus
	 *     Addition returns Plus
	 *     Addition.Plus_1_0_0_0_0 returns Plus
	 *     Addition.Minus_1_0_0_1_0 returns Plus
	 *     Multiplication returns Plus
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns Plus
	 *     Prefixed returns Plus
	 *     Atomic returns Plus
	 *     ParenthesizedExpression returns Plus
	 *
	 * Constraint:
	 *     (left=Addition_Plus_1_0_0_0_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ArrayExpression
	 *     BooleanExpression returns ArrayExpression
	 *     BooleanExpression.BooleanExpression_1_0_0 returns ArrayExpression
	 *     Comparison returns ArrayExpression
	 *     Comparison.Comparison_1_0_0 returns ArrayExpression
	 *     Membership returns ArrayExpression
	 *     Membership.Membership_1_0_0 returns ArrayExpression
	 *     Equals returns ArrayExpression
	 *     Equals.Equals_1_0_0 returns ArrayExpression
	 *     Addition returns ArrayExpression
	 *     Addition.Plus_1_0_0_0_0 returns ArrayExpression
	 *     Addition.Minus_1_0_0_1_0 returns ArrayExpression
	 *     Multiplication returns ArrayExpression
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns ArrayExpression
	 *     Prefixed returns ArrayExpression
	 *     Atomic returns ArrayExpression
	 *     ArrayExpression returns ArrayExpression
	 *     ParenthesizedExpression returns ArrayExpression
	 *
	 * Constraint:
	 *     (expression+=Expression expression+=Expression*)
	 */
	protected void sequence_ArrayExpression(ISerializationContext context, ArrayExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionReference
	 *     BooleanExpression returns FunctionReference
	 *     BooleanExpression.BooleanExpression_1_0_0 returns FunctionReference
	 *     Comparison returns FunctionReference
	 *     Comparison.Comparison_1_0_0 returns FunctionReference
	 *     Membership returns FunctionReference
	 *     Membership.Membership_1_0_0 returns FunctionReference
	 *     Equals returns FunctionReference
	 *     Equals.Equals_1_0_0 returns FunctionReference
	 *     Addition returns FunctionReference
	 *     Addition.Plus_1_0_0_0_0 returns FunctionReference
	 *     Addition.Minus_1_0_0_1_0 returns FunctionReference
	 *     Multiplication returns FunctionReference
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns FunctionReference
	 *     Prefixed returns FunctionReference
	 *     Atomic returns FunctionReference
	 *     ParenthesizedExpression returns FunctionReference
	 *
	 * Constraint:
	 *     ref=Function
	 */
	protected void sequence_Atomic(ISerializationContext context, FunctionReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.FUNCTION_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.FUNCTION_REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getRefFunctionParserRuleCall_4_1_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PropertyExpresssion
	 *     BooleanExpression returns PropertyExpresssion
	 *     BooleanExpression.BooleanExpression_1_0_0 returns PropertyExpresssion
	 *     Comparison returns PropertyExpresssion
	 *     Comparison.Comparison_1_0_0 returns PropertyExpresssion
	 *     Membership returns PropertyExpresssion
	 *     Membership.Membership_1_0_0 returns PropertyExpresssion
	 *     Equals returns PropertyExpresssion
	 *     Equals.Equals_1_0_0 returns PropertyExpresssion
	 *     Addition returns PropertyExpresssion
	 *     Addition.Plus_1_0_0_0_0 returns PropertyExpresssion
	 *     Addition.Minus_1_0_0_1_0 returns PropertyExpresssion
	 *     Multiplication returns PropertyExpresssion
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns PropertyExpresssion
	 *     Prefixed returns PropertyExpresssion
	 *     Atomic returns PropertyExpresssion
	 *     ParenthesizedExpression returns PropertyExpresssion
	 *
	 * Constraint:
	 *     ref=Property
	 */
	protected void sequence_Atomic(ISerializationContext context, PropertyExpresssion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.PROPERTY_EXPRESSSION__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.PROPERTY_EXPRESSSION__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getRefPropertyParserRuleCall_6_1_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableReference
	 *     BooleanExpression returns VariableReference
	 *     BooleanExpression.BooleanExpression_1_0_0 returns VariableReference
	 *     Comparison returns VariableReference
	 *     Comparison.Comparison_1_0_0 returns VariableReference
	 *     Membership returns VariableReference
	 *     Membership.Membership_1_0_0 returns VariableReference
	 *     Equals returns VariableReference
	 *     Equals.Equals_1_0_0 returns VariableReference
	 *     Addition returns VariableReference
	 *     Addition.Plus_1_0_0_0_0 returns VariableReference
	 *     Addition.Minus_1_0_0_1_0 returns VariableReference
	 *     Multiplication returns VariableReference
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns VariableReference
	 *     Prefixed returns VariableReference
	 *     Atomic returns VariableReference
	 *     ParenthesizedExpression returns VariableReference
	 *
	 * Constraint:
	 *     ref=Variable
	 */
	protected void sequence_Atomic(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.VARIABLE_REFERENCE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.VARIABLE_REFERENCE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getRefVariableParserRuleCall_5_1_0(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanExpression
	 *     BooleanExpression returns BooleanExpression
	 *     BooleanExpression.BooleanExpression_1_0_0 returns BooleanExpression
	 *     Comparison returns BooleanExpression
	 *     Comparison.Comparison_1_0_0 returns BooleanExpression
	 *     Membership returns BooleanExpression
	 *     Membership.Membership_1_0_0 returns BooleanExpression
	 *     Equals returns BooleanExpression
	 *     Equals.Equals_1_0_0 returns BooleanExpression
	 *     Addition returns BooleanExpression
	 *     Addition.Plus_1_0_0_0_0 returns BooleanExpression
	 *     Addition.Minus_1_0_0_1_0 returns BooleanExpression
	 *     Multiplication returns BooleanExpression
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns BooleanExpression
	 *     Prefixed returns BooleanExpression
	 *     Atomic returns BooleanExpression
	 *     ParenthesizedExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     (left=BooleanExpression_BooleanExpression_1_0_0 (op='||' | op='&&' | op='and' | op='or') right=Comparison)
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns CollectionFunction
	 *     CollectionFunction returns CollectionFunction
	 *
	 * Constraint:
	 *     (function=CollectionFunctionCall refexp=Expression? resultKey+=Key*)
	 */
	protected void sequence_CollectionFunction(ISerializationContext context, CollectionFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     BooleanExpression returns Comparison
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0_0 returns Comparison
	 *     Membership returns Comparison
	 *     Membership.Membership_1_0_0 returns Comparison
	 *     Equals returns Comparison
	 *     Equals.Equals_1_0_0 returns Comparison
	 *     Addition returns Comparison
	 *     Addition.Plus_1_0_0_0_0 returns Comparison
	 *     Addition.Minus_1_0_0_1_0 returns Comparison
	 *     Multiplication returns Comparison
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns Comparison
	 *     Prefixed returns Comparison
	 *     Atomic returns Comparison
	 *     ParenthesizedExpression returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0_0 (op='<' | op='>' | op='<=' | op='>=') right=Membership)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns ConcatFunc
	 *     ConcatFunc returns ConcatFunc
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression+)
	 */
	protected void sequence_ConcatFunc(ISerializationContext context, ConcatFunc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Contains
	 *     Contains returns Contains
	 *
	 * Constraint:
	 *     (input=Expression search=Expression)
	 */
	protected void sequence_Contains(ISerializationContext context, Contains semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CONTAINS__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CONTAINS__INPUT));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CONTAINS__SEARCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CONTAINS__SEARCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainsAccess().getInputExpressionParserRuleCall_1_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getContainsAccess().getSearchExpressionParserRuleCall_3_0(), semanticObject.getSearch());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns CurrentDate
	 *     CurrentDate returns CurrentDate
	 *
	 * Constraint:
	 *     (format='"MM/dd/yyyy"' | format='"yyyyMMdd"' | format='"yyyy-MM-dd"' | format='"ms"' | format=STRING)?
	 */
	protected void sequence_CurrentDate(ISerializationContext context, CurrentDate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns DateFormat
	 *     DateFormat returns DateFormat
	 *
	 * Constraint:
	 *     (
	 *         (from='"MM/dd/yyyy"' | from='"yyyyMMdd"' | from='"yyyy-MM-dd"' | from='"ms"' | from=STRING) 
	 *         (to='"MM/dd/yyyy"' | to='"yyyyMMdd"' | to='"yyyy-MM-dd"' | to='"ms"' | to=STRING) 
	 *         exp=Expression
	 *     )
	 */
	protected void sequence_DateFormat(ISerializationContext context, DateFormat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns DayDifference
	 *     DayDifference returns DayDifference
	 *
	 * Constraint:
	 *     (from=Expression to=Expression (formatter='"MM/dd/yyyy"' | formatter='"yyyyMMdd"' | formatter='"yyyy-MM-dd"'))
	 */
	protected void sequence_DayDifference(ISerializationContext context, DayDifference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns DedupFunc
	 *     DedupFunc returns DedupFunc
	 *
	 * Constraint:
	 *     (exp=Expression key=SchemaVariable?)
	 */
	protected void sequence_DedupFunc(ISerializationContext context, DedupFunc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     variable=Variable
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.DELETE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.DELETE__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteAccess().getVariableVariableParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equals
	 *     BooleanExpression returns Equals
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Equals
	 *     Comparison returns Equals
	 *     Comparison.Comparison_1_0_0 returns Equals
	 *     Membership returns Equals
	 *     Membership.Membership_1_0_0 returns Equals
	 *     Equals returns Equals
	 *     Equals.Equals_1_0_0 returns Equals
	 *     Addition returns Equals
	 *     Addition.Plus_1_0_0_0_0 returns Equals
	 *     Addition.Minus_1_0_0_1_0 returns Equals
	 *     Multiplication returns Equals
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns Equals
	 *     Prefixed returns Equals
	 *     Atomic returns Equals
	 *     ParenthesizedExpression returns Equals
	 *
	 * Constraint:
	 *     (left=Equals_Equals_1_0_0 (op='==' | op='!=' | op='=~' | op='!~' | op='is') right=Addition)
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Extract
	 *     Extract returns Extract
	 *
	 * Constraint:
	 *     (input=Expression range=Range)
	 */
	protected void sequence_Extract(ISerializationContext context, Extract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.EXTRACT__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.EXTRACT__INPUT));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.EXTRACT__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.EXTRACT__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtractAccess().getInputExpressionParserRuleCall_1_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getExtractAccess().getRangeRangeParserRuleCall_3_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns FilterFunc
	 *     FilterFunc returns FilterFunc
	 *
	 * Constraint:
	 *     (exp=Expression condtion=BooleanExpression)
	 */
	protected void sequence_FilterFunc(ISerializationContext context, FilterFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.FILTER_FUNC__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.FILTER_FUNC__EXP));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.FILTER_FUNC__CONDTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.FILTER_FUNC__CONDTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilterFuncAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getFilterFuncAccess().getCondtionBooleanExpressionParserRuleCall_3_0(), semanticObject.getCondtion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns FindFirstFunc
	 *     FindFirstFunc returns FindFirstFunc
	 *
	 * Constraint:
	 *     (exp=Expression condition=BooleanExpression)
	 */
	protected void sequence_FindFirstFunc(ISerializationContext context, FindFirstFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.FIND_FIRST_FUNC__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.FIND_FIRST_FUNC__EXP));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.FIND_FIRST_FUNC__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.FIND_FIRST_FUNC__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFindFirstFuncAccess().getExpExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getFindFirstFuncAccess().getConditionBooleanExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (exp=Expression key=Expression delimiter=STRING last=STRING?)
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns Json
	 *     Json returns Json
	 *
	 * Constraint:
	 *     exp=SchemaVariable
	 */
	protected void sequence_Json(ISerializationContext context, Json semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.JSON__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.JSON__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJsonAccess().getExpSchemaVariableParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Key
	 *
	 * Constraint:
	 *     (id=AllowedKeyword exp=Expression?)
	 */
	protected void sequence_Key(ISerializationContext context, Key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns LastFunc
	 *     LastFunc returns LastFunc
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_LastFunc(ISerializationContext context, LastFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LAST_FUNC__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LAST_FUNC__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLastFuncAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Length
	 *     Length returns Length
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_Length(ISerializationContext context, Length semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LENGTH__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LENGTH__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLengthAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     BooleanExpression returns BooleanLiteral
	 *     BooleanExpression.BooleanExpression_1_0_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.Comparison_1_0_0 returns BooleanLiteral
	 *     Membership returns BooleanLiteral
	 *     Membership.Membership_1_0_0 returns BooleanLiteral
	 *     Equals returns BooleanLiteral
	 *     Equals.Equals_1_0_0 returns BooleanLiteral
	 *     Addition returns BooleanLiteral
	 *     Addition.Plus_1_0_0_0_0 returns BooleanLiteral
	 *     Addition.Minus_1_0_0_1_0 returns BooleanLiteral
	 *     Multiplication returns BooleanLiteral
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns BooleanLiteral
	 *     Prefixed returns BooleanLiteral
	 *     Atomic returns BooleanLiteral
	 *     LiteralExpression returns BooleanLiteral
	 *     ParenthesizedExpression returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NullLiteral
	 *     BooleanExpression returns NullLiteral
	 *     BooleanExpression.BooleanExpression_1_0_0 returns NullLiteral
	 *     Comparison returns NullLiteral
	 *     Comparison.Comparison_1_0_0 returns NullLiteral
	 *     Membership returns NullLiteral
	 *     Membership.Membership_1_0_0 returns NullLiteral
	 *     Equals returns NullLiteral
	 *     Equals.Equals_1_0_0 returns NullLiteral
	 *     Addition returns NullLiteral
	 *     Addition.Plus_1_0_0_0_0 returns NullLiteral
	 *     Addition.Minus_1_0_0_1_0 returns NullLiteral
	 *     Multiplication returns NullLiteral
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns NullLiteral
	 *     Prefixed returns NullLiteral
	 *     Atomic returns NullLiteral
	 *     LiteralExpression returns NullLiteral
	 *     ParenthesizedExpression returns NullLiteral
	 *
	 * Constraint:
	 *     value='null'
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, NullLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.NULL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.NULL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueNullKeyword_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     BooleanExpression returns NumberLiteral
	 *     BooleanExpression.BooleanExpression_1_0_0 returns NumberLiteral
	 *     Comparison returns NumberLiteral
	 *     Comparison.Comparison_1_0_0 returns NumberLiteral
	 *     Membership returns NumberLiteral
	 *     Membership.Membership_1_0_0 returns NumberLiteral
	 *     Equals returns NumberLiteral
	 *     Equals.Equals_1_0_0 returns NumberLiteral
	 *     Addition returns NumberLiteral
	 *     Addition.Plus_1_0_0_0_0 returns NumberLiteral
	 *     Addition.Minus_1_0_0_1_0 returns NumberLiteral
	 *     Multiplication returns NumberLiteral
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns NumberLiteral
	 *     Prefixed returns NumberLiteral
	 *     Atomic returns NumberLiteral
	 *     LiteralExpression returns NumberLiteral
	 *     ParenthesizedExpression returns NumberLiteral
	 *
	 * Constraint:
	 *     value=NUMBER
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueNUMBERParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     BooleanExpression returns StringLiteral
	 *     BooleanExpression.BooleanExpression_1_0_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0_0 returns StringLiteral
	 *     Membership returns StringLiteral
	 *     Membership.Membership_1_0_0 returns StringLiteral
	 *     Equals returns StringLiteral
	 *     Equals.Equals_1_0_0 returns StringLiteral
	 *     Addition returns StringLiteral
	 *     Addition.Plus_1_0_0_0_0 returns StringLiteral
	 *     Addition.Minus_1_0_0_1_0 returns StringLiteral
	 *     Multiplication returns StringLiteral
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns StringLiteral
	 *     Prefixed returns StringLiteral
	 *     Atomic returns StringLiteral
	 *     LiteralExpression returns StringLiteral
	 *     ParenthesizedExpression returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_LiteralExpression(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralExpressionAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns LowerFunc
	 *     LowerFunc returns LowerFunc
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_LowerFunc(ISerializationContext context, LowerFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LOWER_FUNC__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LOWER_FUNC__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowerFuncAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns MapFunc
	 *     MapFunc returns MapFunc
	 *
	 * Constraint:
	 *     (exp=Expression range=Range? aliasKey=AllowedKeyword? (returnexp=Expression | statement+=MapStatement+))
	 */
	protected void sequence_MapFunc(ISerializationContext context, MapFunc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapStatement returns MapStatement
	 *
	 * Constraint:
	 *     (resultKey+=Key resultKey+=Key* exp=Expression)
	 */
	protected void sequence_MapStatement(ISerializationContext context, MapStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Membership
	 *     BooleanExpression returns Membership
	 *     BooleanExpression.BooleanExpression_1_0_0 returns Membership
	 *     Comparison returns Membership
	 *     Comparison.Comparison_1_0_0 returns Membership
	 *     Membership returns Membership
	 *     Membership.Membership_1_0_0 returns Membership
	 *     Equals returns Membership
	 *     Equals.Equals_1_0_0 returns Membership
	 *     Addition returns Membership
	 *     Addition.Plus_1_0_0_0_0 returns Membership
	 *     Addition.Minus_1_0_0_1_0 returns Membership
	 *     Multiplication returns Membership
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns Membership
	 *     Prefixed returns Membership
	 *     Atomic returns Membership
	 *     ParenthesizedExpression returns Membership
	 *
	 * Constraint:
	 *     (left=Membership_Membership_1_0_0 (op='in' | op='not_in') right+=Expression right+=Expression*)
	 */
	protected void sequence_Membership(ISerializationContext context, Membership semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MultiOrDivOrMod
	 *     BooleanExpression returns MultiOrDivOrMod
	 *     BooleanExpression.BooleanExpression_1_0_0 returns MultiOrDivOrMod
	 *     Comparison returns MultiOrDivOrMod
	 *     Comparison.Comparison_1_0_0 returns MultiOrDivOrMod
	 *     Membership returns MultiOrDivOrMod
	 *     Membership.Membership_1_0_0 returns MultiOrDivOrMod
	 *     Equals returns MultiOrDivOrMod
	 *     Equals.Equals_1_0_0 returns MultiOrDivOrMod
	 *     Addition returns MultiOrDivOrMod
	 *     Addition.Plus_1_0_0_0_0 returns MultiOrDivOrMod
	 *     Addition.Minus_1_0_0_1_0 returns MultiOrDivOrMod
	 *     Multiplication returns MultiOrDivOrMod
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns MultiOrDivOrMod
	 *     Prefixed returns MultiOrDivOrMod
	 *     Atomic returns MultiOrDivOrMod
	 *     ParenthesizedExpression returns MultiOrDivOrMod
	 *
	 * Constraint:
	 *     (left=Multiplication_MultiOrDivOrMod_1_0_0 (op='*' | op='/' | op='%') right=Prefixed)
	 */
	protected void sequence_Multiplication(ISerializationContext context, MultiOrDivOrMod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns ParentFunc
	 *     ParentFunc returns ParentFunc
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_ParentFunc(ISerializationContext context, ParentFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.PARENT_FUNC__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.PARENT_FUNC__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParentFuncAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns PickFirst
	 *     PickFirst returns PickFirst
	 *
	 * Constraint:
	 *     (exp+=Expression exp+=Expression+ condition=Comparison)
	 */
	protected void sequence_PickFirst(ISerializationContext context, PickFirst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ArithmeticSigned
	 *     BooleanExpression returns ArithmeticSigned
	 *     BooleanExpression.BooleanExpression_1_0_0 returns ArithmeticSigned
	 *     Comparison returns ArithmeticSigned
	 *     Comparison.Comparison_1_0_0 returns ArithmeticSigned
	 *     Membership returns ArithmeticSigned
	 *     Membership.Membership_1_0_0 returns ArithmeticSigned
	 *     Equals returns ArithmeticSigned
	 *     Equals.Equals_1_0_0 returns ArithmeticSigned
	 *     Addition returns ArithmeticSigned
	 *     Addition.Plus_1_0_0_0_0 returns ArithmeticSigned
	 *     Addition.Minus_1_0_0_1_0 returns ArithmeticSigned
	 *     Multiplication returns ArithmeticSigned
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns ArithmeticSigned
	 *     Prefixed returns ArithmeticSigned
	 *     Atomic returns ArithmeticSigned
	 *     ParenthesizedExpression returns ArithmeticSigned
	 *
	 * Constraint:
	 *     expression=Atomic
	 */
	protected void sequence_Prefixed(ISerializationContext context, ArithmeticSigned semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.ARITHMETIC_SIGNED__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.ARITHMETIC_SIGNED__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixedAccess().getExpressionAtomicParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanNegation
	 *     BooleanExpression returns BooleanNegation
	 *     BooleanExpression.BooleanExpression_1_0_0 returns BooleanNegation
	 *     Comparison returns BooleanNegation
	 *     Comparison.Comparison_1_0_0 returns BooleanNegation
	 *     Membership returns BooleanNegation
	 *     Membership.Membership_1_0_0 returns BooleanNegation
	 *     Equals returns BooleanNegation
	 *     Equals.Equals_1_0_0 returns BooleanNegation
	 *     Addition returns BooleanNegation
	 *     Addition.Plus_1_0_0_0_0 returns BooleanNegation
	 *     Addition.Minus_1_0_0_1_0 returns BooleanNegation
	 *     Multiplication returns BooleanNegation
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns BooleanNegation
	 *     Prefixed returns BooleanNegation
	 *     Atomic returns BooleanNegation
	 *     ParenthesizedExpression returns BooleanNegation
	 *
	 * Constraint:
	 *     expression=Atomic
	 */
	protected void sequence_Prefixed(ISerializationContext context, BooleanNegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BOOLEAN_NEGATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BOOLEAN_NEGATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixedAccess().getExpressionAtomicParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     key=STRING
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.PROPERTY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.PROPERTY__KEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getKeySTRINGTerminalRuleCall_1_0(), semanticObject.getKey());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (low=Expression? diff='..' high=Expression?)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns RemoveFunc
	 *     RemoveFunc returns RemoveFunc
	 *
	 * Constraint:
	 *     (exp=Expression condition=BooleanExpression)
	 */
	protected void sequence_RemoveFunc(ISerializationContext context, RemoveFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.REMOVE_FUNC__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.REMOVE_FUNC__EXP));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.REMOVE_FUNC__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.REMOVE_FUNC__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemoveFuncAccess().getExpExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getRemoveFuncAccess().getConditionBooleanExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SchemaVariable returns SchemaVariable
	 *
	 * Constraint:
	 *     (global='::'? key+=Key key+=Key*)
	 */
	protected void sequence_SchemaVariable(ISerializationContext context, SchemaVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns SortFunc
	 *     SortFunc returns SortFunc
	 *
	 * Constraint:
	 *     (exp=Expression key=SchemaVariable type=ORDER_TYPE?)
	 */
	protected void sequence_SortFunc(ISerializationContext context, SortFunc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionFunctionCall returns Split
	 *     Split returns Split
	 *
	 * Constraint:
	 *     (exp=Expression regex=STRING)
	 */
	protected void sequence_Split(ISerializationContext context, Split semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.SPLIT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.SPLIT__EXP));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.SPLIT__REGEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.SPLIT__REGEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSplitAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getSplitAccess().getRegexSTRINGTerminalRuleCall_3_0(), semanticObject.getRegex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TernaryExpression
	 *     BooleanExpression returns TernaryExpression
	 *     BooleanExpression.BooleanExpression_1_0_0 returns TernaryExpression
	 *     Comparison returns TernaryExpression
	 *     Comparison.Comparison_1_0_0 returns TernaryExpression
	 *     Membership returns TernaryExpression
	 *     Membership.Membership_1_0_0 returns TernaryExpression
	 *     Equals returns TernaryExpression
	 *     Equals.Equals_1_0_0 returns TernaryExpression
	 *     Addition returns TernaryExpression
	 *     Addition.Plus_1_0_0_0_0 returns TernaryExpression
	 *     Addition.Minus_1_0_0_1_0 returns TernaryExpression
	 *     Multiplication returns TernaryExpression
	 *     Multiplication.MultiOrDivOrMod_1_0_0 returns TernaryExpression
	 *     Prefixed returns TernaryExpression
	 *     Atomic returns TernaryExpression
	 *     TernaryExpression returns TernaryExpression
	 *     ParenthesizedExpression returns TernaryExpression
	 *
	 * Constraint:
	 *     (expression=BooleanExpression truevalue=Atomic falsevalue=Atomic?)
	 */
	protected void sequence_TernaryExpression(ISerializationContext context, TernaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns TranslateUnicode
	 *     TranslateUnicode returns TranslateUnicode
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_TranslateUnicode(ISerializationContext context, TranslateUnicode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.TRANSLATE_UNICODE__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.TRANSLATE_UNICODE__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTranslateUnicodeAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Function returns UUIDFunc
	 *     UUIDFunc returns UUIDFunc
	 *
	 * Constraint:
	 *     {UUIDFunc}
	 */
	protected void sequence_UUIDFunc(ISerializationContext context, UUIDFunc semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns UpperFunc
	 *     UpperFunc returns UpperFunc
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_UpperFunc(ISerializationContext context, UpperFunc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.UPPER_FUNC__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.UPPER_FUNC__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpperFuncAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     schemaVariable=SchemaVariable
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.VARIABLE__SCHEMA_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.VARIABLE__SCHEMA_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getSchemaVariableSchemaVariableParserRuleCall_0(), semanticObject.getSchemaVariable());
		feeder.finish();
	}
	
	
}
