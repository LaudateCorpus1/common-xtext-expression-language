/**
 * generated by Xtext 2.25.0
 */
package com.intuit.dsl.expression.util;

import com.intuit.dsl.expression.*;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notifier;

import org.eclipse.emf.common.notify.impl.AdapterFactoryImpl;

import org.eclipse.emf.ecore.EObject;

/**
 * <!-- begin-user-doc -->
 * The <b>Adapter Factory</b> for the model.
 * It provides an adapter <code>createXXX</code> method for each class of the model.
 * <!-- end-user-doc -->
 * @see com.intuit.dsl.expression.ExpressionPackage
 * @generated
 */
public class ExpressionAdapterFactory extends AdapterFactoryImpl
{
  /**
   * The cached model package.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected static ExpressionPackage modelPackage;

  /**
   * Creates an instance of the adapter factory.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public ExpressionAdapterFactory()
  {
    if (modelPackage == null)
    {
      modelPackage = ExpressionPackage.eINSTANCE;
    }
  }

  /**
   * Returns whether this factory is applicable for the type of the object.
   * <!-- begin-user-doc -->
   * This implementation returns <code>true</code> if the object is either the model's package or is an instance object of the model.
   * <!-- end-user-doc -->
   * @return whether this factory is applicable for the type of the object.
   * @generated
   */
  @Override
  public boolean isFactoryForType(Object object)
  {
    if (object == modelPackage)
    {
      return true;
    }
    if (object instanceof EObject)
    {
      return ((EObject)object).eClass().getEPackage() == modelPackage;
    }
    return false;
  }

  /**
   * The switch that delegates to the <code>createXXX</code> methods.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected ExpressionSwitch<Adapter> modelSwitch =
    new ExpressionSwitch<Adapter>()
    {
      @Override
      public Adapter caseExpression(Expression object)
      {
        return createExpressionAdapter();
      }
      @Override
      public Adapter caseLiteralExpression(LiteralExpression object)
      {
        return createLiteralExpressionAdapter();
      }
      @Override
      public Adapter caseTernaryExpression(TernaryExpression object)
      {
        return createTernaryExpressionAdapter();
      }
      @Override
      public Adapter caseFunction(Function object)
      {
        return createFunctionAdapter();
      }
      @Override
      public Adapter caseCollectionFunction(CollectionFunction object)
      {
        return createCollectionFunctionAdapter();
      }
      @Override
      public Adapter caseCollectionFunctionCall(CollectionFunctionCall object)
      {
        return createCollectionFunctionCallAdapter();
      }
      @Override
      public Adapter caseParentFunc(ParentFunc object)
      {
        return createParentFuncAdapter();
      }
      @Override
      public Adapter caseLastFunc(LastFunc object)
      {
        return createLastFuncAdapter();
      }
      @Override
      public Adapter caseDelete(Delete object)
      {
        return createDeleteAdapter();
      }
      @Override
      public Adapter caseSplit(Split object)
      {
        return createSplitAdapter();
      }
      @Override
      public Adapter caseContains(Contains object)
      {
        return createContainsAdapter();
      }
      @Override
      public Adapter caseExtract(Extract object)
      {
        return createExtractAdapter();
      }
      @Override
      public Adapter caseDateFormat(DateFormat object)
      {
        return createDateFormatAdapter();
      }
      @Override
      public Adapter caseAddToDate(AddToDate object)
      {
        return createAddToDateAdapter();
      }
      @Override
      public Adapter caseFilterFunc(FilterFunc object)
      {
        return createFilterFuncAdapter();
      }
      @Override
      public Adapter caseFindFirstFunc(FindFirstFunc object)
      {
        return createFindFirstFuncAdapter();
      }
      @Override
      public Adapter caseRemoveFunc(RemoveFunc object)
      {
        return createRemoveFuncAdapter();
      }
      @Override
      public Adapter caseSortFunc(SortFunc object)
      {
        return createSortFuncAdapter();
      }
      @Override
      public Adapter caseDedupFunc(DedupFunc object)
      {
        return createDedupFuncAdapter();
      }
      @Override
      public Adapter caseMapFunc(MapFunc object)
      {
        return createMapFuncAdapter();
      }
      @Override
      public Adapter caseRange(Range object)
      {
        return createRangeAdapter();
      }
      @Override
      public Adapter caseMapStatement(MapStatement object)
      {
        return createMapStatementAdapter();
      }
      @Override
      public Adapter caseConcatFunc(ConcatFunc object)
      {
        return createConcatFuncAdapter();
      }
      @Override
      public Adapter caseLength(Length object)
      {
        return createLengthAdapter();
      }
      @Override
      public Adapter caseLowerFunc(LowerFunc object)
      {
        return createLowerFuncAdapter();
      }
      @Override
      public Adapter caseUpperFunc(UpperFunc object)
      {
        return createUpperFuncAdapter();
      }
      @Override
      public Adapter caseUUIDFunc(UUIDFunc object)
      {
        return createUUIDFuncAdapter();
      }
      @Override
      public Adapter caseJson(Json object)
      {
        return createJsonAdapter();
      }
      @Override
      public Adapter caseJoin(Join object)
      {
        return createJoinAdapter();
      }
      @Override
      public Adapter caseDayDifference(DayDifference object)
      {
        return createDayDifferenceAdapter();
      }
      @Override
      public Adapter caseTranslateUnicode(TranslateUnicode object)
      {
        return createTranslateUnicodeAdapter();
      }
      @Override
      public Adapter caseCurrentDate(CurrentDate object)
      {
        return createCurrentDateAdapter();
      }
      @Override
      public Adapter casePickFirst(PickFirst object)
      {
        return createPickFirstAdapter();
      }
      @Override
      public Adapter caseVariable(Variable object)
      {
        return createVariableAdapter();
      }
      @Override
      public Adapter caseKey(Key object)
      {
        return createKeyAdapter();
      }
      @Override
      public Adapter caseSchemaVariable(SchemaVariable object)
      {
        return createSchemaVariableAdapter();
      }
      @Override
      public Adapter caseProperty(Property object)
      {
        return createPropertyAdapter();
      }
      @Override
      public Adapter caseBooleanExpression(BooleanExpression object)
      {
        return createBooleanExpressionAdapter();
      }
      @Override
      public Adapter caseComparison(Comparison object)
      {
        return createComparisonAdapter();
      }
      @Override
      public Adapter caseMembership(Membership object)
      {
        return createMembershipAdapter();
      }
      @Override
      public Adapter caseEquals(Equals object)
      {
        return createEqualsAdapter();
      }
      @Override
      public Adapter casePlus(Plus object)
      {
        return createPlusAdapter();
      }
      @Override
      public Adapter caseMinus(Minus object)
      {
        return createMinusAdapter();
      }
      @Override
      public Adapter caseMultiOrDivOrMod(MultiOrDivOrMod object)
      {
        return createMultiOrDivOrModAdapter();
      }
      @Override
      public Adapter caseBooleanNegation(BooleanNegation object)
      {
        return createBooleanNegationAdapter();
      }
      @Override
      public Adapter caseArithmeticSigned(ArithmeticSigned object)
      {
        return createArithmeticSignedAdapter();
      }
      @Override
      public Adapter caseFunctionReference(FunctionReference object)
      {
        return createFunctionReferenceAdapter();
      }
      @Override
      public Adapter caseVariableReference(VariableReference object)
      {
        return createVariableReferenceAdapter();
      }
      @Override
      public Adapter casePropertyExpresssion(PropertyExpresssion object)
      {
        return createPropertyExpresssionAdapter();
      }
      @Override
      public Adapter caseNumberLiteral(NumberLiteral object)
      {
        return createNumberLiteralAdapter();
      }
      @Override
      public Adapter caseStringLiteral(StringLiteral object)
      {
        return createStringLiteralAdapter();
      }
      @Override
      public Adapter caseNullLiteral(NullLiteral object)
      {
        return createNullLiteralAdapter();
      }
      @Override
      public Adapter caseBooleanLiteral(BooleanLiteral object)
      {
        return createBooleanLiteralAdapter();
      }
      @Override
      public Adapter caseArrayExpression(ArrayExpression object)
      {
        return createArrayExpressionAdapter();
      }
      @Override
      public Adapter defaultCase(EObject object)
      {
        return createEObjectAdapter();
      }
    };

  /**
   * Creates an adapter for the <code>target</code>.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @param target the object to adapt.
   * @return the adapter for the <code>target</code>.
   * @generated
   */
  @Override
  public Adapter createAdapter(Notifier target)
  {
    return modelSwitch.doSwitch((EObject)target);
  }


  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Expression <em>Expression</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Expression
   * @generated
   */
  public Adapter createExpressionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.LiteralExpression <em>Literal Expression</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.LiteralExpression
   * @generated
   */
  public Adapter createLiteralExpressionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.TernaryExpression <em>Ternary Expression</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.TernaryExpression
   * @generated
   */
  public Adapter createTernaryExpressionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Function <em>Function</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Function
   * @generated
   */
  public Adapter createFunctionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.CollectionFunction <em>Collection Function</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.CollectionFunction
   * @generated
   */
  public Adapter createCollectionFunctionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.CollectionFunctionCall <em>Collection Function Call</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.CollectionFunctionCall
   * @generated
   */
  public Adapter createCollectionFunctionCallAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.ParentFunc <em>Parent Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.ParentFunc
   * @generated
   */
  public Adapter createParentFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.LastFunc <em>Last Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.LastFunc
   * @generated
   */
  public Adapter createLastFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Delete <em>Delete</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Delete
   * @generated
   */
  public Adapter createDeleteAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Split <em>Split</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Split
   * @generated
   */
  public Adapter createSplitAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Contains <em>Contains</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Contains
   * @generated
   */
  public Adapter createContainsAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Extract <em>Extract</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Extract
   * @generated
   */
  public Adapter createExtractAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.DateFormat <em>Date Format</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.DateFormat
   * @generated
   */
  public Adapter createDateFormatAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.AddToDate <em>Add To Date</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.AddToDate
   * @generated
   */
  public Adapter createAddToDateAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.FilterFunc <em>Filter Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.FilterFunc
   * @generated
   */
  public Adapter createFilterFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.FindFirstFunc <em>Find First Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.FindFirstFunc
   * @generated
   */
  public Adapter createFindFirstFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.RemoveFunc <em>Remove Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.RemoveFunc
   * @generated
   */
  public Adapter createRemoveFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.SortFunc <em>Sort Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.SortFunc
   * @generated
   */
  public Adapter createSortFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.DedupFunc <em>Dedup Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.DedupFunc
   * @generated
   */
  public Adapter createDedupFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.MapFunc <em>Map Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.MapFunc
   * @generated
   */
  public Adapter createMapFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Range <em>Range</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Range
   * @generated
   */
  public Adapter createRangeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.MapStatement <em>Map Statement</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.MapStatement
   * @generated
   */
  public Adapter createMapStatementAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.ConcatFunc <em>Concat Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.ConcatFunc
   * @generated
   */
  public Adapter createConcatFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Length <em>Length</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Length
   * @generated
   */
  public Adapter createLengthAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.LowerFunc <em>Lower Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.LowerFunc
   * @generated
   */
  public Adapter createLowerFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.UpperFunc <em>Upper Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.UpperFunc
   * @generated
   */
  public Adapter createUpperFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.UUIDFunc <em>UUID Func</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.UUIDFunc
   * @generated
   */
  public Adapter createUUIDFuncAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Json <em>Json</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Json
   * @generated
   */
  public Adapter createJsonAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Join <em>Join</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Join
   * @generated
   */
  public Adapter createJoinAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.DayDifference <em>Day Difference</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.DayDifference
   * @generated
   */
  public Adapter createDayDifferenceAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.TranslateUnicode <em>Translate Unicode</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.TranslateUnicode
   * @generated
   */
  public Adapter createTranslateUnicodeAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.CurrentDate <em>Current Date</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.CurrentDate
   * @generated
   */
  public Adapter createCurrentDateAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.PickFirst <em>Pick First</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.PickFirst
   * @generated
   */
  public Adapter createPickFirstAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Variable <em>Variable</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Variable
   * @generated
   */
  public Adapter createVariableAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Key <em>Key</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Key
   * @generated
   */
  public Adapter createKeyAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.SchemaVariable <em>Schema Variable</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.SchemaVariable
   * @generated
   */
  public Adapter createSchemaVariableAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Property <em>Property</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Property
   * @generated
   */
  public Adapter createPropertyAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.BooleanExpression <em>Boolean Expression</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.BooleanExpression
   * @generated
   */
  public Adapter createBooleanExpressionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Comparison <em>Comparison</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Comparison
   * @generated
   */
  public Adapter createComparisonAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Membership <em>Membership</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Membership
   * @generated
   */
  public Adapter createMembershipAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Equals <em>Equals</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Equals
   * @generated
   */
  public Adapter createEqualsAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Plus <em>Plus</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Plus
   * @generated
   */
  public Adapter createPlusAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.Minus <em>Minus</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.Minus
   * @generated
   */
  public Adapter createMinusAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.MultiOrDivOrMod <em>Multi Or Div Or Mod</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.MultiOrDivOrMod
   * @generated
   */
  public Adapter createMultiOrDivOrModAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.BooleanNegation <em>Boolean Negation</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.BooleanNegation
   * @generated
   */
  public Adapter createBooleanNegationAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.ArithmeticSigned <em>Arithmetic Signed</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.ArithmeticSigned
   * @generated
   */
  public Adapter createArithmeticSignedAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.FunctionReference <em>Function Reference</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.FunctionReference
   * @generated
   */
  public Adapter createFunctionReferenceAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.VariableReference <em>Variable Reference</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.VariableReference
   * @generated
   */
  public Adapter createVariableReferenceAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.PropertyExpresssion <em>Property Expresssion</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.PropertyExpresssion
   * @generated
   */
  public Adapter createPropertyExpresssionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.NumberLiteral <em>Number Literal</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.NumberLiteral
   * @generated
   */
  public Adapter createNumberLiteralAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.StringLiteral <em>String Literal</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.StringLiteral
   * @generated
   */
  public Adapter createStringLiteralAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.NullLiteral <em>Null Literal</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.NullLiteral
   * @generated
   */
  public Adapter createNullLiteralAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.BooleanLiteral <em>Boolean Literal</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.BooleanLiteral
   * @generated
   */
  public Adapter createBooleanLiteralAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for an object of class '{@link com.intuit.dsl.expression.ArrayExpression <em>Array Expression</em>}'.
   * <!-- begin-user-doc -->
   * This default implementation returns null so that we can easily ignore cases;
   * it's useful to ignore a case when inheritance will catch all the cases anyway.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @see com.intuit.dsl.expression.ArrayExpression
   * @generated
   */
  public Adapter createArrayExpressionAdapter()
  {
    return null;
  }

  /**
   * Creates a new adapter for the default case.
   * <!-- begin-user-doc -->
   * This default implementation returns null.
   * <!-- end-user-doc -->
   * @return the new adapter.
   * @generated
   */
  public Adapter createEObjectAdapter()
  {
    return null;
  }

} //ExpressionAdapterFactory
